<!DOCTYPE html>
<html>
  <head>
    <title>The various flavours of union types</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# The various flavours of union types

---

class: center, middle

# Non-discriminated unions

---

## C/C++

```c
union int_or_string {
  int   int_value;
  char* string_value;
};
```

---

## C/C++

```c
union `int_or_string` {
  int   int_value;
  char* string_value;
};
```

---

## C/C++

```c
union int_or_string {
  `int   int_value;`
  char* string_value;
};
```

---

## C/C++

```c
union int_or_string {
  int   int_value;
  `char* string_value;`
};
```

---

## C/C++

```c
#include<stdio.h>

void print_union(union int_or_string e) {
    ???
}
```

---

class: center, middle

# Explicitly discriminated unions

---

## C/C++

```c
enum typetag {
    int_tag,
    string_tag
};

struct int_or_string {
    enum typetag tag;

    union {
        int   int_value;
        char* string_value;
    } union_value;
};
```

---

## C/C++

```c
*enum typetag {
*   int_tag,
*   string_tag
*};

struct int_or_string {
    enum typetag tag;

    union {
        int   int_value;
        char* string_value;
    } union_value;
};
```

---

## C/C++

```c
enum typetag {
    `int_tag`,
    string_tag
};

struct int_or_string {
    enum typetag tag;

    union {
        int   int_value;
        char* string_value;
    } union_value;
};
```

---

## C/C++

```c
enum typetag {
    int_tag,
    `string_tag`
};

struct int_or_string {
    enum typetag tag;

    union {
        int   int_value;
        char* string_value;
    } union_value;
};
```

---

## C/C++

```c
enum typetag {
    int_tag,
    string_tag
};

*struct int_or_string {
*   enum typetag tag;
*
*   union {
*       int   int_value;
*       char* string_value;
*   } union_value;
*};
```

---

## C/C++

```c
enum typetag {
    int_tag,
    string_tag
};

struct int_or_string {
    `enum typetag tag;`

    union {
        int   int_value;
        char* string_value;
    } union_value;
};
```

---

## C/C++

```c
enum typetag {
    int_tag,
    string_tag
};

struct int_or_string {
    enum typetag tag;

*   union {
*       int   int_value;
*       char* string_value;
*   } union_value;
};
```

---

## C/C++

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(e.tag == int_tag) {
        printf("int: %i", e.union_value.int_value);
    }
    else {
        printf("string: %s", e.union_value.string_value);
    }
}
```

---

## C/C++

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(`e.tag == int_tag`) {
        printf("int: %i", `e.union_value.int_value`);
    }
    else {
        printf("string: %s", e.union_value.string_value);
    }
}
```

---

## C/C++

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(e.tag == int_tag) {
        printf("int: %i", e.union_value.int_value);
    }
    else {
        printf("string: %s", `e.union_value.string_value`);
    }
}
```

---

class: center, middle

# Discriminated unions
# (sum types)

---

## Haskell

```haskell
data IntOrString = I Int
                 | S String
```

---

## Haskell

```haskell
data `IntOrString` = I Int
                 | S String
```

---

## Haskell

```haskell
data IntOrString = `I Int`
                 | S String
```

---

## Haskell

```haskell
data IntOrString = I Int
                 | `S String`
```

---

## Haskell

```haskell
data IntOrString = I Int
                 | S String
```

```haskell
printUnion is = case is of
  (I i) -> putStrLn ("int: " ++ (show i))
  (S s) -> putStrLn ("string: " ++ s)
```

---

## Haskell

```haskell
data IntOrString = I Int
                 | S String
```

```haskell
printUnion is = case is of
  (`I i`) -> putStrLn ("int: " ++ (show i))
  (S s) -> putStrLn ("string: " ++ s)
```

---

## Haskell

```haskell
data IntOrString = I Int
                 | S String
```

```haskell
printUnion is = case is of
  (I i) -> putStrLn ("int: " ++ (show i))
  (`S s`) -> putStrLn ("string: " ++ s)
```

---

## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

---

## Scala

```scala
sealed trait `IntOrString`

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

---

## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class `I(value: Int)` extends IntOrString
  case class S(value: String) extends IntOrString
}
```

---

## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class `S(value: String)` extends IntOrString
}
```

---

## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

```scala
def printUnion(is: IntOrString) = is match {
  case IntOrString.I(i) => println(s"int: $i")
  case IntOrString.S(s) => println(s"string: $s")
}
```

---

## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

```scala
def printUnion(`is: IntOrString`) = is match {
  case IntOrString.I(i) => println(s"int: $i")
  case IntOrString.S(s) => println(s"string: $s")
}
```

---
## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

```scala
def printUnion(is: IntOrString) = is match {
  case `IntOrString.I(i)` => println(s"int: $i")
  case IntOrString.S(s) => println(s"string: $s")
}
```

---
## Scala

```scala
sealed trait IntOrString

object IntOrString {
  case class I(value: Int) extends IntOrString
  case class S(value: String) extends IntOrString
}
```

```scala
def printUnion(is: IntOrString) = is match {
  case IntOrString.I(i) => println(s"int: $i")
  case `IntOrString.S(s)` => println(s"string: $s")
}
```
---

class: center, middle

# Dotty-style unions?

---

## Discriminated?

```scala
def printUnion(is: Int | String) = is match {
  case i: Int    => println(s"int: $i")
  case s: String => println(s"string: $s")
}
```

---

## Discriminated?

```scala
def printUnion(`is: Int | String`) = is match {
  case i: Int    => println(s"int: $i")
  case s: String => println(s"string: $s")
}
```

---

## Discriminated?

```scala
def printUnion(is: Int | String) = is match {
  case `i: Int`    => println(s"int: $i")
  case s: String => println(s"string: $s")
}
```

---

## Discriminated?

```scala
def printUnion(is: Int | String) = is match {
  case i: Int    => println(s"int: $i")
  case `s: String` => println(s"string: $s")
}
```

---

## Non-discriminated?

```scala
def printUnion(ii: Int | Int) = ii match {
  case i1: Int => println(s"left int: $i1")
  case i2: Int => println(s"right int: $i2")
}
```

---

## Non-discriminated?

```scala
def printUnion(ii: `Int | Int`) = ii match {
  case i1: Int => println(s"left int: $i1")
  case i2: Int => println(s"right int: $i2")
}
```

---

## Non-discriminated?

```scala
def printUnion(ii: Int | Int) = ii match {
  case `i1: Int` => println(s"left int: $i1")
  case i2: Int => println(s"right int: $i2")
}
```

---

## Non-discriminated?

```scala
def printUnion(ii: Int | Int) = ii match {
  case i1: Int => println(s"left int: $i1")
  case `i2: Int` => println(s"right int: $i2")
} //   ^^^^^^^
  //   Unreachable case
```

---

## Key takeaways

* Discriminated means: you can differentiate between values at runtime.
--

* There are multiple ways of encoding this.
--

* Scala 2 uses runtime type information (I think).

    </textarea>
    <script src="js/remark.js" type="text/javascript"></script>
    <script src="js/katex.js"></script>
    <script src="js/auto-render.js"></script>
    <link rel="stylesheet" href="css/katex.css">

    <script type="text/javascript">
var renderMath = function() {
  renderMathInElement(document.body);
}
var slideshow = remark.create({
  highlightStyle: 'github',
  highlightSpans: true,
  highlightLines: true
}, renderMath);
    </script>
  </body>
</html>
